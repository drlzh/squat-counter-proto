<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Adaptive Squat Counter DS1 (Tunable)</title>
<style>
  :root {
    --primary-color: #007aff;
    --background-color: #f9f9f9;
    --card-bg: #ffffff;
    --border-color: #e0e0e0;
    --text-color: #1c1c1e;
    --muted-text: #6e6e73;
    --rounded: 12px;
  }
  * { box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-color: var(--background-color);
    color: var(--text-color);
    margin: 0;
    padding: 2rem 1rem;
  }
  h1 {
    font-size: 2.5rem;
    margin-bottom: 2rem;
    text-align: center;
    color: var(--primary-color);
  }
  .container {
    max-width: 900px;
    margin: auto;
    display: flex;
    flex-direction: column;
    gap: 2rem;
  }
  .card {
    background-color: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: var(--rounded);
    padding: 1.5rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  }
  .section-title {
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 1rem;
  }
  #count {
    font-size: 5rem;
    font-weight: bold;
    text-align: center;
    color: seagreen;
  }
  #status {
    font-size: 1rem;
    white-space: pre-line;
    color: var(--text-color);
    text-align: center;
  }
  .button-group {
    display: flex;
    justify-content: center;
    gap: 1rem;
    flex-wrap: wrap;
    margin-top: 1rem;
  }
  button {
    background-color: var(--primary-color);
    color: white;
    font-size: 1rem;
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: var(--rounded);
    cursor: pointer;
    transition: background 0.2s ease;
  }
  button:hover {
    background-color: #005ecb;
  }
  input[type="number"] {
    font-size: 1rem;
    padding: 0.4rem;
    border: 1px solid var(--border-color);
    border-radius: var(--rounded);
    width: 90px;
  }
  label {
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 0.95rem;
  }
  .config-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 0.8rem;
    margin-top: 1rem;
  }
  #repLog {
    max-height: 250px;
    overflow-y: auto;
    white-space: pre-line;
  }
  .log-entry {
    padding: 0.75rem;
    border-bottom: 1px solid var(--border-color);
    font-size: 0.95rem;
  }
  .log-percentile {
    margin-top: 0.25rem;
    font-weight: bold;
    color: var(--primary-color);
  }
  .checkbox-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }
  #modelStatus {
    font-size: 0.85rem;
    color: var(--muted-text);
    margin-top: 0.5rem;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.22.0/dist/ort.js"></script>
</head>
<body>
<h1>Adaptive Squat Counter</h1>
<div class="container">

  <!-- Live performance -->
  <div class="card">
    <div class="section-title">Live Performance</div>
    <div id="count">0</div>
    <div id="status">Waiting for motion permission...</div>
    <div class="button-group">
      <button id="startButton">Start</button>
      <button id="testSoundButton">Test Sound</button>
    </div>
  </div>

  <!-- Squat history -->
  <div class="card">
    <div class="section-title">Squat History</div>
    <div id="repLog"></div>
  </div>

  <!-- Fitness Estimation -->
  <div class="card">
    <div class="section-title">Fitness Estimation</div>
    <label class="checkbox-label">
      <input type="checkbox" id="toggleModel" />
      Enable Fitness Percentile Estimation
    </label>
    <div id="modelStatus">Model not loaded.</div>
  </div>

  <!-- Original Hyperparameters -->
  <div class="card">
    <div class="section-title">Original Hyperparameters</div>
    <div class="config-group">
      <label>TARGET_HZ: <input type="number" id="inputHz" value="50" /></label>
      <label>SAMPLE_SIZE: <input type="number" id="inputSampleSize" value="31" /></label>
      <label>WINDOW_DURATION (s): <input type="number" id="inputWindowDuration" value="2.0" step="0.1" /></label>
      <label>VALLEY_WINDOW: <input type="number" id="inputValleyWindow" value="5" /></label>
      <label>VALLEY_POSITIONS: <input type="text" id="inputValleyPositions" value="4" /></label>
      <label>CORRELATION_THRESHOLD: <input type="number" id="inputThreshold" value="0.85" step="0.01" /></label>
      <label>AMPLITUDE_THRESHOLD: <input type="number" id="inputAmpThreshold" value="2.3" step="0.1" /></label>
      <label>ADAPTIVE_K: <input type="number" id="inputAdaptiveK" value="0.85" step="0.01" /></label>
      <label>MIN_CD (s): <input type="number" id="inputMinCd" value="2.0" step="0.1" /></label>
      <label>MAX_CD (s): <input type="number" id="inputMaxCd" value="3.0" step="0.1" /></label>
    </div>
  </div>

  <!-- New Patch Parameters -->
  <div class="card">
    <div class="section-title">Experimental Parameters</div>
    <div class="config-group">
      <label>Gravity α: <input type="number" id="inputGravityAlpha" value="0.98" step="0.01" /></label>
      <label>EMA_ALPHA: <input type="number" id="inputEMA" value="0.25" step="0.01" /></label>
      <label>HP_CUTOFF (Hz): <input type="number" id="inputHpCut" value="0.3" step="0.05" /></label>
      <label>LP_CUTOFF (Hz): <input type="number" id="inputLpCut" value="2.0" step="0.1" /></label>
      <label>SG_WINDOW: <input type="number" id="inputSgWin" value="9" /></label>
      <label>SG_POLY: <input type="number" id="inputSgPoly" value="3" /></label>
      <label>FSM velDown: <input type="number" id="inputVelDown" value="-0.2" step="0.01" /></label>
      <label>FSM velUp: <input type="number" id="inputVelUp" value="0.2" step="0.01" /></label>
      <label>FSM velComplete: <input type="number" id="inputVelComplete" value="-0.1" step="0.01" /></label>
      <label>Adaptive Amp Mult: <input type="number" id="inputNoiseMult" value="4" step="0.5" /></label>
    </div>
  </div>

</div>

<audio id="chimeSound" src="chime.mp3" preload="auto"></audio>

  <script>
/* ---------- GLOBALS ---------- */
let TARGET_HZ, SAMPLE_SIZE, WINDOW_DURATION, WINDOW_SIZE, VALLEY_WINDOW, VALLEY_POSITIONS,
    CORRELATION_THRESHOLD, AMPLITUDE_THRESHOLD, ADAPTIVE_K, MIN_CD, MAX_CD;
let gravityAlpha, EMA_ALPHA, HP_CUTOFF, LP_CUTOFF, SG_WINDOW, SG_POLY;
let velDown, velUp, velComplete, noiseMult;

let buffer = [], intervalBuffer = [];
let repCount = 0, lastRepTime = -Infinity;
let onnxSession = null, fitnessPercentileEnabled = false;

/* ---------- PATCH STATE ---------- */
let gravity = { x: 0, y: 0, z: 0 };
let ema = { x: 0, y: 0, z: 0 };
let hp = { y: 0, prev: 0 };
let lp = { y: 0, prev: 0 };
let phase = "standing";

/* ---------- UI REFS ---------- */
const countDisplay = document.getElementById("count");
const statusDisplay = document.getElementById("status");
const repLog = document.getElementById("repLog");
const startButton = document.getElementById("startButton");
const testSoundButton = document.getElementById("testSoundButton");
const chimeSound = document.getElementById("chimeSound");
const toggleModel = document.getElementById("toggleModel");
const modelStatus = document.getElementById("modelStatus");

/* ---------- MODEL TOGGLE ---------- */
toggleModel.onchange = async () => {
  fitnessPercentileEnabled = toggleModel.checked;
  if (fitnessPercentileEnabled && !onnxSession) {
    modelStatus.textContent = "⏳ Loading model...";
    try {
      onnxSession = await ort.InferenceSession.create("fitness_percentile_model.onnx");
      modelStatus.textContent = "✅ Model loaded.";
    } catch {
      modelStatus.textContent = "❌ Model load failed.";
    }
  } else if (!fitnessPercentileEnabled) {
    modelStatus.textContent = "Model disabled.";
  }
};

/* ---------- TEST SOUND ---------- */
testSoundButton.onclick = () => {
  chimeSound.currentTime = 0;
  chimeSound.play().catch(() => alert("Audio could not play."));
};

/* ---------- START BUTTON ---------- */
startButton.onclick = async () => {
  // Read parameters from UI
  TARGET_HZ = +document.getElementById("inputHz").value;
  SAMPLE_SIZE = +document.getElementById("inputSampleSize").value;
  WINDOW_DURATION = +document.getElementById("inputWindowDuration").value;
  WINDOW_SIZE = Math.floor(WINDOW_DURATION * TARGET_HZ);
  VALLEY_WINDOW = +document.getElementById("inputValleyWindow").value;
  VALLEY_POSITIONS = document.getElementById("inputValleyPositions").value.split(',').map(v => +v.trim());
  CORRELATION_THRESHOLD = +document.getElementById("inputThreshold").value;
  AMPLITUDE_THRESHOLD = +document.getElementById("inputAmpThreshold").value;
  ADAPTIVE_K = +document.getElementById("inputAdaptiveK").value;
  MIN_CD = +document.getElementById("inputMinCd").value;
  MAX_CD = +document.getElementById("inputMaxCd").value;
  gravityAlpha = +document.getElementById("inputGravityAlpha").value;
  EMA_ALPHA = +document.getElementById("inputEMA").value;
  HP_CUTOFF = +document.getElementById("inputHpCut").value;
  LP_CUTOFF = +document.getElementById("inputLpCut").value;
  SG_WINDOW = +document.getElementById("inputSgWin").value;
  SG_POLY = +document.getElementById("inputSgPoly").value;
  velDown = +document.getElementById("inputVelDown").value;
  velUp = +document.getElementById("inputVelUp").value;
  velComplete = +document.getElementById("inputVelComplete").value;
  noiseMult = +document.getElementById("inputNoiseMult").value;

  // Reset state
  startButton.disabled = true;
  buffer = []; intervalBuffer = []; repCount = 0; lastRepTime = -Infinity;
  countDisplay.textContent = "0";
  statusDisplay.textContent = "Tracking motion... Start squatting!";

  try {
    if (typeof DeviceMotionEvent.requestPermission === "function") {
      const resp = await DeviceMotionEvent.requestPermission();
      if (resp !== "granted") throw new Error("Permission denied");
    }
    window.addEventListener("devicemotion", handleMotion);
  } catch {
    statusDisplay.textContent = "❌ Motion access denied.";
  }
};

/* ---------- PATCH FILTERS ---------- */
function updateGravity(acc) {
  gravity.x = gravityAlpha * gravity.x + (1 - gravityAlpha) * acc.x;
  gravity.y = gravityAlpha * gravity.y + (1 - gravityAlpha) * acc.y;
  gravity.z = gravityAlpha * gravity.z + (1 - gravityAlpha) * acc.z;
}
function lowPass(acc) {
  ema.x = EMA_ALPHA * acc.x + (1 - EMA_ALPHA) * ema.x;
  ema.y = EMA_ALPHA * acc.y + (1 - EMA_ALPHA) * ema.y;
  ema.z = EMA_ALPHA * acc.z + (1 - EMA_ALPHA) * ema.z;
  return { x: ema.x, y: ema.y, z: ema.z };
}
function bandPass(v) {
  const hpAlpha = HP_CUTOFF / (HP_CUTOFF + (1 / (2 * Math.PI * (1 / TARGET_HZ))));
  const lpAlpha = (1 / (2 * Math.PI * (1 / TARGET_HZ))) / (LP_CUTOFF + (1 / (2 * Math.PI * (1 / TARGET_HZ))));
  hp.y = hpAlpha * (hp.y + v - hp.prev); hp.prev = v;
  lp.y = lpAlpha * hp.y + (1 - lpAlpha) * (lp.prev || hp.y); lp.prev = lp.y;
  return lp.y;
}
function sgFilter(data) {
  return savitzkyGolay(data, 1, { windowSize: SG_WINDOW, polynomial: SG_POLY, derivative: 0 });
}
function updatePhase(sig) {
  const n = sig.length; if (n < 3) return phase;
  const vel = (sig[n - 1] - sig[n - 3]) / (2 / TARGET_HZ);
  if (phase === "standing" && vel < velDown) phase = "descending";
  else if (phase === "descending" && Math.abs(sig[n - 1] - Math.min(...sig.slice(-VALLEY_WINDOW))) < 0.05) phase = "bottom";
  else if (phase === "bottom" && vel > velUp) phase = "ascending";
  else if (phase === "ascending" && vel > velComplete) { phase = "standing"; return "completed"; }
  return phase;
}
function pearson(x, y) {
  const n = x.length;
  const meanX = x.reduce((a, b) => a + b, 0) / n;
  const meanY = y.reduce((a, b) => a + b, 0) / n;
  let num = 0, dx2 = 0, dy2 = 0;
  for (let i = 0; i < n; i++) {
    const dx = x[i] - meanX, dy = y[i] - meanY;
    num += dx * dy; dx2 += dx * dx; dy2 += dy * dy;
  }
  const denom = Math.sqrt(dx2 * dy2);
  return denom === 0 ? 0 : num / denom;
}

/* ---------- MAIN MOTION HANDLER ---------- */
function handleMotion(event) {
  const acc = event.accelerationIncludingGravity;
  const now = Date.now() / 1000;
  if (!acc?.x || !acc?.y || !acc?.z) return;

  // Gravity removal
  updateGravity(acc);
  const gx = acc.x - gravity.x;
  const gy = acc.y - gravity.y;
  const gz = acc.z - gravity.z;

  // EMA smoothing
  const smoothed = lowPass({ x: gx, y: gy, z: gz });

  // Store
  buffer.push({ x: smoothed.x, y: -smoothed.y, z: smoothed.z, t: now });
  if (buffer.length > 2 * TARGET_HZ) buffer.shift();
  if (buffer.length < SAMPLE_SIZE) return;

  // Filtered signals
  const yFilt = sgFilter(buffer.map(p => p.y));
  const zFilt = sgFilter(buffer.map(p => p.z));
  const fusedRaw = yFilt.map((v, i) => (v + zFilt[i]) / 2);
  const fused = fusedRaw.map(bandPass);

  // Correlation & valley check
  if (pearson(yFilt, zFilt) < CORRELATION_THRESHOLD) return;
  const lastWindow = fused.slice(-VALLEY_WINDOW);
  const valleyIdx = VALLEY_POSITIONS[0];
  const isValley = VALLEY_POSITIONS.every(i => lastWindow[i] === Math.min(...lastWindow));
  if (!isValley) return;

  // Adaptive amplitude
  const amp = Math.abs(lastWindow[valleyIdx] - Math.max(...lastWindow));
  const meanFused = fused.reduce((a,b)=>a+b,0)/fused.length;
  const noiseStd = Math.sqrt(lastWindow.reduce((s,v)=>s+(v-meanFused)**2,0)/lastWindow.length);
  const adaptiveAmpThr = Math.max(AMPLITUDE_THRESHOLD, noiseStd * noiseMult);
  if (amp < adaptiveAmpThr) return;

  // FSM cadence check
  if (updatePhase(fused) !== "completed") return;

  // Cooldown
  const t = now;
  const timeSinceLast = t - lastRepTime;
  const avgInterval = intervalBuffer.length >= 2
    ? intervalBuffer.reduce((a, b) => a + b, 0) / intervalBuffer.length
    : MIN_CD;
  const cooldown = Math.max(MIN_CD, Math.min(MAX_CD, ADAPTIVE_K * avgInterval));
  if (timeSinceLast < cooldown) return;

  // Count rep
  repCount++;
  countDisplay.textContent = repCount.toString();
  intervalBuffer.push(timeSinceLast);
  if (intervalBuffer.length > 10) intervalBuffer.shift();
  lastRepTime = t;

  // Metrics
  const seg = buffer.slice(Math.max(0, buffer.length - Math.floor(TARGET_HZ)));
  const mag = seg.map(p => Math.sqrt(p.x ** 2 + p.y ** 2 + p.z ** 2));
  const time = seg.map(p => p.t);
  const vel = [0];
  for (let i = 1; i < mag.length; i++) {
    const dt = time[i] - time[i - 1];
    vel.push(vel[i - 1] + 0.5 * (mag[i] + mag[i - 1]) * dt);
  }
  const disp = [0];
  for (let i = 1; i < vel.length; i++) {
    const dt = time[i] - time[i - 1];
    disp.push(disp[i - 1] + 0.5 * (vel[i] + vel[i - 1]) * dt);
  }
  const displacement = disp[disp.length - 1] - disp[0];
  const descentDuration = time[time.length - 1] - time[0];
  const descentSpeed = displacement / descentDuration;

  let speedQuality = "✅ Good";
  if (descentSpeed < 0.3) speedQuality = "⚠️ Slow";
  if (descentSpeed < 0.15) speedQuality = "❌ Ineffective";

  const rawFused = seg.map(p => (p.y + p.z) / 2);
  function computeSharpness(sig, thresholdRatio = 0.5) {
    const min = Math.min(...sig);
    const max = Math.max(...sig);
    const depth = max - min;
    const valleyIndex = sig.indexOf(min);
    let left = valleyIndex, right = valleyIndex;
    while (left > 0 && sig[left] < min + thresholdRatio * depth) left--;
    while (right < sig.length - 1 && sig[right] < min + thresholdRatio * depth) right++;
    const width = right - left + 1;
    return depth / width;
  }
  const sharpness = computeSharpness(rawFused);
  let sharpQuality = "✅ Good";
  if (sharpness < 0.3) sharpQuality = "⚠️ Flat or Slow";
  if (sharpness < 0.15) sharpQuality = "❌ No Clear Dip";

  const logText =
    `#${repCount} @ ${t.toFixed(2)}s\n` +
    `↳ Descent Speed: ${descentSpeed.toFixed(3)} (${speedQuality})\n` +
    `↳ Sharpness: ${sharpness.toFixed(3)} (${sharpQuality})`;

  statusDisplay.textContent = logText;

  const logEntry = document.createElement("div");
  logEntry.className = "log-entry";
  logEntry.textContent = logText;
  repLog.appendChild(logEntry);

  if (fitnessPercentileEnabled && onnxSession) {
    predictPercentile(descentSpeed, sharpness).then(percentile => {
      if (percentile !== null) {
        const pLine = document.createElement("div");
        pLine.className = "log-percentile";
        pLine.textContent = `↳ Estimated Fitness Percentile: ${percentile.toFixed(2)}%`;
        logEntry.appendChild(pLine);
      }
    });
  }

  chimeSound.currentTime = 0;
  chimeSound.play().catch(() => {});
}

/* ---------- PERCENTILE ---------- */
async function predictPercentile(descentSpeed, sharpness) {
  if (!onnxSession) return null;
  try {
    const inputTensor = new ort.Tensor('float32', new Float32Array([descentSpeed, sharpness]), [1, 2]);
    const results = await onnxSession.run({ input: inputTensor });
    return results[Object.keys(results)[0]].data[0];
  } catch {
    return null;
  }
}

/* ---------- FLEXIBLE SG (NO DEPENDENCIES) ---------- */
function savitzkyGolay(data, h = 1, options = {}) {
  const { windowSize, polynomial, derivative = 0 } = options;
  if (windowSize % 2 === 0 || windowSize < 5) throw new RangeError('Window size must be odd and >= 5');
  if (polynomial < 1 || polynomial > 3) throw new RangeError('Polynomial must be 1–3');

  const half = Math.floor(windowSize / 2);
  // Build Vandermonde matrix
  const A = [];
  for (let i = -half; i <= half; i++) {
    const row = [];
    for (let j = 0; j <= polynomial; j++) row.push(Math.pow(i, j));
    A.push(row);
  }
  const AT = transpose(A);
  const ATA = multiply(AT, A);
  const ATAinv = invertMatrix(ATA);
  const coeffs = multiply(ATAinv, AT)[derivative];
  const factor = factorial(derivative) / Math.pow(h, derivative);

  const output = [];
  for (let k = half; k < data.length - half; k++) {
    let acc = 0;
    for (let l = -half; l <= half; l++) acc += coeffs[l + half] * data[k + l];
    output.push(acc * factor);
  }
  return output;
}
function transpose(m) {
  return m[0].map((_, i) => m.map(row => row[i]));
}
function multiply(A, B) {
  const result = Array(A.length).fill(0).map(() => Array(B[0].length).fill(0));
  for (let i = 0; i < A.length; i++) {
    for (let j = 0; j < B[0].length; j++) {
      for (let k = 0; k < B.length; k++) {
        result[i][j] += A[i][k] * B[k][j];
      }
    }
  }
  return result;
}
function invertMatrix(m) {
  const n = m.length;
  const I = m.map((row, i) => row.map((_, j) => (i === j ? 1 : 0)));
  const M = m.map(row => row.slice());
  for (let i = 0; i < n; i++) {
    let maxEl = Math.abs(M[i][i]);
    let maxRow = i;
    for (let k = i + 1; k < n; k++) {
      if (Math.abs(M[k][i]) > maxEl) { maxEl = Math.abs(M[k][i]); maxRow = k; }
    }
    [M[i], M[maxRow]] = [M[maxRow], M[i]];
    [I[i], I[maxRow]] = [I[maxRow], I[i]];
    const div = M[i][i];
    for (let j = 0; j < n; j++) {
      M[i][j] /= div;
      I[i][j] /= div;
    }
    for (let k = 0; k < n; k++) {
      if (k !== i) {
        const c = M[k][i];
        for (let j = 0; j < n; j++) {
          M[k][j] -= c * M[i][j];
          I[k][j] -= c * I[i][j];
        }
      }
    }
  }
  return I;
}
function factorial(n) { return n <= 1 ? 1 : n * factorial(n - 1); }
</script>
</body>
</html>
